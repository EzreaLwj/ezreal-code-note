# RocketMQ 特性



## 一、背景

RocketMQ 作为一款消息队列，做到了**低延迟**、**高可用**、**高性能**，但做到这些在用户的眼里可能是刚刚达标。为啥这么说呢？因为业界其他的消息队列也许大多数都能够做到以上三点，只是大家做到的程度不尽相同。

RocketMQ 之所以能被运用得这么广泛，我认为它多样化的**特性（Feature）** 是功不可没的，接下来就让我们来简单了解下这些特性。

![RocketMQ特性](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410133913314.png)



可以看到，RocketMQ 总共有：**订阅发布**、**顺序消费**、**消息过滤**、**消息消费重试**、**消息可靠**、**至少一次消费模型**、**事务消息**、**延迟队列**、**回溯消息**、**流量控制**、**消息重投**、**死信队列**等共十二种特性。当然，RocketMQ 也有一些自己特有的特性，例如消息过滤、事务消息等。



## 二、特性详解



### 2.1 顺序消费

顺序消费其实也算上面提到的那种较为 “基础” 的功能。因为大家可能会认为：难道不是本来就应该保证消息的顺序吗，但此顺序非彼顺序，它更多的是站在上帝视角的顺序，当我们把视角切到 RocketMQ 这台精密仪器的内部，你会发现这里其实有两种顺序：**分区有序**和**全局有序**。



#### 分区有序

一个 Topic 中会存在多个 MessageQueue。如果不同的 Message 被投递到了同一个 MessageQueue 当中，那么在这个 MessageQueue 内，消息就是分区有序的。由于一个 Topic 中存在多个 MessageQueue。假设现在有 3 个 MessageQueue，理论上来说，这 4 条消息是有可能分别投递到不同的 MessageQueue 内的：

![image-20240410154014948](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410154014948.png)



其中，Message1、4 被分配到了 ID 为 0 的 MessageQueue，Message2、3 分别被分配到了 ID 为 1、2 的 MessageQueue。这样一来，我们称 Message1、4 在 MessageQueue0 内是**分区有序**的。

但是需要注意的是，对 Consumer 来说，它是可以并行消费多个 MessageQueue 当中的 Message 的。拿上面的图举例子，假设消费者组只有1个实例，那么它会**并行**消费 3 个 MessageQueue 的数据，这样一来，Consumer 第一个消费的 Message 就不一定是 Message1 了，尽管它是最先被投递到队列中的。

有的同学就可能就有疑问了：我就是想让同一批类型的消息进入到同一个 MessageQueue，在电商场景下，对一个 ID 为 144 的订单，总共产生了三个事件：订单已创建、订单已更新、订单已完成。它们在业务上是有严格的顺序的，那么在消费时肯定也不能乱序。

这就需要全局有序来支持了。



#### 全局有序

全局有序就是刚刚讲的上帝视角的顺序。

举个例子，在食堂排队，大家在队列中的位置则是根据到达的时间来定的，先来后到对吧？再比如，Message1、Message2、Message3、 Message4 先后被投递到消息队列，FIFO（先进先出），那么就像下图所表达的一样，它们的顺序也应该如此：

![image-20240410161226324](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410161226324.png)



那么基于在`分区有序`中了解到的多 MessageQueue 的设计，RocketMQ 是如何做到全局有序的呢？

其实很简单，那就是一个 Topic 只分配一个 MessageQueue。这样一来所有的 Message 都是全局有序的，并且从另一个角度来看它也算**单分区下的分区有序，进而演变成的全局有序**。



但大家要注意，在全局有序的模式下是不支持并行消费的。首先，必须保证全局有序，并行消费则无法保障；其次，只有1个 MessageQueue，想要并行也没办法。



### 2.2 消息过滤

说到消息过滤，可能大多数同学的脑海里会浮现出这样的流程：我们从消息队列里获取了一批 Message，然后根据 Message 内容判断出其具体的类型，等于就留下，不等于就将其过滤掉。

举个例子，可能根据某个 `type` 字段，我们可以判断出这几条 Message 是属于“订单创建”的，而另外几条是属于“物流信息”，而我们当前的业务只需要关注“订单创建”，于是我们在代码中手动地将“物流信息”类的消息给忽略掉，如下图所示：

![image-20240410162743330](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410162743330.png)



而 RocketMQ 的消息过滤特性就内置了此功能。我们只需要给投递的 Message 打上了一个 Tag 即可。举个例子，某个 Topic 里有包含了 Tag 为如下的 Message：

- 订单信息；
- 物流信息；

Consumer 后续消费时只需要指定订阅 Tag 为物流信息的消息，消费者只会拉取 **Tag = 物流信息**的消息，业务系统不需要做额外任何事。

![image-20240410163058865](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410163058865.png)

- 这个其实就类似于社交平台上我们**关注**的某些人一样，在`关注动态`这一栏，我们不会收到其他没有被关注的人的动态推送。
- 这种消息队列内置的功能实现会给我们带来很多便利，不用自己去封装，运行效率还能得到保障，也不容易引入由于自研而带来的一些 Bug。



### 2.3 事务消息

其实这里的事务和大家常见的数据库事务逻辑上是**同一个概念**，即将一组操作打包成一个整体，这些操作**要么一起成功，要么一起失败**。

我们可以给出事务消息的定义：所谓事务消息就是把发送消息的那个服务的**本地事务**，与**投递消息到 MQ 这个操作组成一个事务**，这里涉及两个操作：

- 本地事务运行、并且成功；
- 投递消息到消息队列成功；

它们两个要么一起成功，要么本地事务回滚、投递到消息队列的消息也会失效。

![事务消息](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410164330626.png)



### 2.4 延迟队列

**延迟队列**也叫定时消息，但其实用定时消息来描述不是很准确。因为常规的定时消息是能够指定任意时间的，比如 43 秒之后，又或者 174 秒之后执行。

但可惜的是 RocketMQ 的定时消息做不到那么灵活。因为它只提供了 18 个时间选项来供用户选择，这里分别对应 18 个 Level，分别是：1s、5s、10s、30s、1m 、2m、3m、4m、5m、6m、7m、8m、9m、10m、20m、30m、1h、2h。

假设我们设定的级别是 5s，那么消费的流程就会如下图所示：

![延迟队列](https://ezreal-tuchuang-1312880100.cos.ap-guangzhou.myqcloud.com/article/image-20240410164911734.png)

- 积分系统作为 Consumer 不会立马收到订单系统刚刚发出去的消息，而是会在 5s 之后收到消息。



### 2.5 死信队列

这个特性用于处理无法被正常消费的消息，那如何定义无法被正常消费？RocketMQ 给出的定义是：**达到最大的重试次数（默认是 16 次），即重试次数达到了 16 次，仍然无法被正常消费。**

那这个时候怎么办呢？直接丢弃吗？当然不是。RocketMQ 会再给这些 Message 一次机会，消息会被放入**死信队列**中，这部分 Message 也有个名字叫**死信消息**。

其实这只是起了一个比较特殊的名字而已，什么死信队列......说到底这些 Message 还是会被存储在一个 Topic 当中，所有的死信队列都会带上 `%DLQ% `的前缀，然后后面跟上消费者组的名称，并且这个 Topic 对消费者来说是不可见的。

放进死信队列之后，Message 会在 3 天之后过期，所以需要及时地处理，不然消息就会永久地丢失。