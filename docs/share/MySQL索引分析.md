# MySQL 索引分析



## 一、背景

验证 MySQL 索引对查询，更新操作速度的影响。



## 二、实例测试



### 2.1 查询分析

|          | 不加索引进行查询 | 根据区分度低的索引进行查询 | 根据区分度高的索引进行查询 | 联合索引-区分度高在前 | 联合索引-区分度低在前 |
| -------- | ---------------- | -------------------------- | -------------------------- | --------------------- | --------------------- |
| **耗时** | 3.377s           | 0.135s                     | 0.011s                     | 0.012s                | 0.016s                |

- 无索引，还是查询字段，非常危险；
- 不要在区分度低的字段上建立索引，这些字段往往是**一对多**的关系，某个 userId 就有可能产生 100万条数据，这样的情况**更适合分库分表**；
- 区分度高的索引，查询效果会特别好；
- 对于联合索引，区分度高的字段在前更有利于查询操作；

> 索引区分度低对查询操作的影响：
>
> 1. 对于字符串类型的索引字段，在排序和比较的时，都是一个一个字母地进行比较。如果区分度较低，表示两个字符串前面部分的字符相似度高，比较的次数就会增多；
> 2. 对于这种情况，我们建议使用分库分表的技术方案，将属于某个 userId 的数据放到指定的库/表中；





### 2.2 更新分析

|      | 不加索引进行更新 | 根据区分度高的索引进行更新 | 根据区分度低的索引进行更新 |
| ---- | ---------------- | -------------------------- | -------------------------- |
| 耗时 | 3.976s           | 0.006s                     | 0.106s                     |

- 对于 InnoDB 存储引擎，如果对不加索引字段进行更新，则会产生锁表的情况，最后会拖垮数据库；
- 对于区分度低的索引进行更新：如果批量更新某个 userId 的数据，也会对很多记录上锁；
- 对于区分度高的索引进行更新：锁的只是本身的一条数据，效率非常高；